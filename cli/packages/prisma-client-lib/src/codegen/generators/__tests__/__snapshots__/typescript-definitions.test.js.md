# Snapshot report for `dist/codegen/generators/__tests__/typescript-definitions.test.js`

The actual snapshot is saved in `typescript-definitions.test.js.snap`.

Generated by [AVA](https://ava.li).

## typescript definitions generator

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import { DocumentNode } from "graphql";␊
    import {␊
      makePrismaClientClass,␊
      BaseClientOptions,␊
      Model␊
    } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &␊
      U[keyof U];␊
    ␊
    export type Maybe<T> = T | undefined | null;␊
    ␊
    export interface Exists {␊
      post: (where?: PostWhereInput) => Promise<boolean>;␊
      user: (where?: UserWhereInput) => Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface Prisma {␊
      $exists: Exists;␊
      $graphql: <T = any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      post: (where: PostWhereUniqueInput) => PostNullablePromise;␊
      posts: (args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<Post>;␊
      postsConnection: (args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => PostConnectionPromise;␊
      user: (where: UserWhereUniqueInput) => UserNullablePromise;␊
      users: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<User>;␊
      usersConnection: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => UserConnectionPromise;␊
      node: (args: { id: ID_Output }) => Node;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createPost: (data: PostCreateInput) => PostPromise;␊
      updatePost: (args: {␊
        data: PostUpdateInput;␊
        where: PostWhereUniqueInput;␊
      }) => PostPromise;␊
      updateManyPosts: (args: {␊
        data: PostUpdateManyMutationInput;␊
        where?: PostWhereInput;␊
      }) => BatchPayloadPromise;␊
      upsertPost: (args: {␊
        where: PostWhereUniqueInput;␊
        create: PostCreateInput;␊
        update: PostUpdateInput;␊
      }) => PostPromise;␊
      deletePost: (where: PostWhereUniqueInput) => PostPromise;␊
      deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;␊
      createUser: (data: UserCreateInput) => UserPromise;␊
      updateUser: (args: {␊
        data: UserUpdateInput;␊
        where: UserWhereUniqueInput;␊
      }) => UserPromise;␊
      updateManyUsers: (args: {␊
        data: UserUpdateManyMutationInput;␊
        where?: UserWhereInput;␊
      }) => BatchPayloadPromise;␊
      upsertUser: (args: {␊
        where: UserWhereUniqueInput;␊
        create: UserCreateInput;␊
        update: UserUpdateInput;␊
      }) => UserPromise;␊
      deleteUser: (where: UserWhereUniqueInput) => UserPromise;␊
      deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      post: (␊
        where?: PostSubscriptionWhereInput␊
      ) => PostSubscriptionPayloadSubscription;␊
      user: (␊
        where?: UserSubscriptionWhereInput␊
      ) => UserSubscriptionPayloadSubscription;␊
    }␊
    ␊
    export interface ClientConstructor<T> {␊
      new (options?: BaseClientOptions): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type PostOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "isPublished_ASC"␊
      | "isPublished_DESC"␊
      | "title_ASC"␊
      | "title_DESC"␊
      | "text_ASC"␊
      | "text_DESC";␊
    ␊
    export type UserOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "email_ASC"␊
      | "email_DESC"␊
      | "password_ASC"␊
      | "password_DESC"␊
      | "name_ASC"␊
      | "name_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export interface UserUpdateOneRequiredWithoutPostsInput {␊
      create?: Maybe<UserCreateWithoutPostsInput>;␊
      update?: Maybe<UserUpdateWithoutPostsDataInput>;␊
      upsert?: Maybe<UserUpsertWithoutPostsInput>;␊
      connect?: Maybe<UserWhereUniqueInput>;␊
    }␊
    ␊
    export type PostWhereUniqueInput = AtLeastOne<{␊
      id: Maybe<ID_Input>;␊
    }>;␊
    ␊
    export interface PostUpdateManyWithoutAuthorInput {␊
      create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;␊
      delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      update?: Maybe<␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput␊
      >;␊
      upsert?: Maybe<␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput␊
      >;␊
      deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      updateMany?: Maybe<␊
        PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput␊
      >;␊
    }␊
    ␊
    export interface UserCreateInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
      posts?: Maybe<PostCreateManyWithoutAuthorInput>;␊
    }␊
    ␊
    export interface PostUpdateManyMutationInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface UserSubscriptionWhereInput {␊
      mutation_in?: Maybe<MutationType[] | MutationType>;␊
      updatedFields_contains?: Maybe<String>;␊
      updatedFields_contains_every?: Maybe<String[] | String>;␊
      updatedFields_contains_some?: Maybe<String[] | String>;␊
      node?: Maybe<UserWhereInput>;␊
      AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
      OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
      NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
    }␊
    ␊
    export interface PostCreateInput {␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
      author: UserCreateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface UserUpdateManyMutationInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
    }␊
    ␊
    export interface UserCreateOneWithoutPostsInput {␊
      create?: Maybe<UserCreateWithoutPostsInput>;␊
      connect?: Maybe<UserWhereUniqueInput>;␊
    }␊
    ␊
    export interface PostUpdateManyWithWhereNestedInput {␊
      where: PostScalarWhereInput;␊
      data: PostUpdateManyDataInput;␊
    }␊
    ␊
    export interface UserCreateWithoutPostsInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export type UserWhereUniqueInput = AtLeastOne<{␊
      id: Maybe<ID_Input>;␊
    }>;␊
    ␊
    export interface PostUpdateInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
      author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;␊
    }␊
    ␊
    export interface PostUpdateWithoutAuthorDataInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface UserUpdateInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
      posts?: Maybe<PostUpdateManyWithoutAuthorInput>;␊
    }␊
    ␊
    export interface UserWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      email?: Maybe<String>;␊
      email_not?: Maybe<String>;␊
      email_in?: Maybe<String[] | String>;␊
      email_not_in?: Maybe<String[] | String>;␊
      email_lt?: Maybe<String>;␊
      email_lte?: Maybe<String>;␊
      email_gt?: Maybe<String>;␊
      email_gte?: Maybe<String>;␊
      email_contains?: Maybe<String>;␊
      email_not_contains?: Maybe<String>;␊
      email_starts_with?: Maybe<String>;␊
      email_not_starts_with?: Maybe<String>;␊
      email_ends_with?: Maybe<String>;␊
      email_not_ends_with?: Maybe<String>;␊
      password?: Maybe<String>;␊
      password_not?: Maybe<String>;␊
      password_in?: Maybe<String[] | String>;␊
      password_not_in?: Maybe<String[] | String>;␊
      password_lt?: Maybe<String>;␊
      password_lte?: Maybe<String>;␊
      password_gt?: Maybe<String>;␊
      password_gte?: Maybe<String>;␊
      password_contains?: Maybe<String>;␊
      password_not_contains?: Maybe<String>;␊
      password_starts_with?: Maybe<String>;␊
      password_not_starts_with?: Maybe<String>;␊
      password_ends_with?: Maybe<String>;␊
      password_not_ends_with?: Maybe<String>;␊
      name?: Maybe<String>;␊
      name_not?: Maybe<String>;␊
      name_in?: Maybe<String[] | String>;␊
      name_not_in?: Maybe<String[] | String>;␊
      name_lt?: Maybe<String>;␊
      name_lte?: Maybe<String>;␊
      name_gt?: Maybe<String>;␊
      name_gte?: Maybe<String>;␊
      name_contains?: Maybe<String>;␊
      name_not_contains?: Maybe<String>;␊
      name_starts_with?: Maybe<String>;␊
      name_not_starts_with?: Maybe<String>;␊
      name_ends_with?: Maybe<String>;␊
      name_not_ends_with?: Maybe<String>;␊
      posts_every?: Maybe<PostWhereInput>;␊
      posts_some?: Maybe<PostWhereInput>;␊
      posts_none?: Maybe<PostWhereInput>;␊
      AND?: Maybe<UserWhereInput[] | UserWhereInput>;␊
      OR?: Maybe<UserWhereInput[] | UserWhereInput>;␊
      NOT?: Maybe<UserWhereInput[] | UserWhereInput>;␊
    }␊
    ␊
    export interface UserUpdateWithoutPostsDataInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
    }␊
    ␊
    export interface PostUpdateManyDataInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface PostCreateManyWithoutAuthorInput {␊
      create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;␊
      connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
    }␊
    ␊
    export interface PostCreateWithoutAuthorInput {␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      isPublished?: Maybe<Boolean>;␊
      isPublished_not?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      title_not?: Maybe<String>;␊
      title_in?: Maybe<String[] | String>;␊
      title_not_in?: Maybe<String[] | String>;␊
      title_lt?: Maybe<String>;␊
      title_lte?: Maybe<String>;␊
      title_gt?: Maybe<String>;␊
      title_gte?: Maybe<String>;␊
      title_contains?: Maybe<String>;␊
      title_not_contains?: Maybe<String>;␊
      title_starts_with?: Maybe<String>;␊
      title_not_starts_with?: Maybe<String>;␊
      title_ends_with?: Maybe<String>;␊
      title_not_ends_with?: Maybe<String>;␊
      text?: Maybe<String>;␊
      text_not?: Maybe<String>;␊
      text_in?: Maybe<String[] | String>;␊
      text_not_in?: Maybe<String[] | String>;␊
      text_lt?: Maybe<String>;␊
      text_lte?: Maybe<String>;␊
      text_gt?: Maybe<String>;␊
      text_gte?: Maybe<String>;␊
      text_contains?: Maybe<String>;␊
      text_not_contains?: Maybe<String>;␊
      text_starts_with?: Maybe<String>;␊
      text_not_starts_with?: Maybe<String>;␊
      text_ends_with?: Maybe<String>;␊
      text_not_ends_with?: Maybe<String>;␊
      author?: Maybe<UserWhereInput>;␊
      AND?: Maybe<PostWhereInput[] | PostWhereInput>;␊
      OR?: Maybe<PostWhereInput[] | PostWhereInput>;␊
      NOT?: Maybe<PostWhereInput[] | PostWhereInput>;␊
    }␊
    ␊
    export interface UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput;␊
      create: UserCreateWithoutPostsInput;␊
    }␊
    ␊
    export interface PostScalarWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      isPublished?: Maybe<Boolean>;␊
      isPublished_not?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      title_not?: Maybe<String>;␊
      title_in?: Maybe<String[] | String>;␊
      title_not_in?: Maybe<String[] | String>;␊
      title_lt?: Maybe<String>;␊
      title_lte?: Maybe<String>;␊
      title_gt?: Maybe<String>;␊
      title_gte?: Maybe<String>;␊
      title_contains?: Maybe<String>;␊
      title_not_contains?: Maybe<String>;␊
      title_starts_with?: Maybe<String>;␊
      title_not_starts_with?: Maybe<String>;␊
      title_ends_with?: Maybe<String>;␊
      title_not_ends_with?: Maybe<String>;␊
      text?: Maybe<String>;␊
      text_not?: Maybe<String>;␊
      text_in?: Maybe<String[] | String>;␊
      text_not_in?: Maybe<String[] | String>;␊
      text_lt?: Maybe<String>;␊
      text_lte?: Maybe<String>;␊
      text_gt?: Maybe<String>;␊
      text_gte?: Maybe<String>;␊
      text_contains?: Maybe<String>;␊
      text_not_contains?: Maybe<String>;␊
      text_starts_with?: Maybe<String>;␊
      text_not_starts_with?: Maybe<String>;␊
      text_ends_with?: Maybe<String>;␊
      text_not_ends_with?: Maybe<String>;␊
      AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
    }␊
    ␊
    export interface PostSubscriptionWhereInput {␊
      mutation_in?: Maybe<MutationType[] | MutationType>;␊
      updatedFields_contains?: Maybe<String>;␊
      updatedFields_contains_every?: Maybe<String[] | String>;␊
      updatedFields_contains_some?: Maybe<String[] | String>;␊
      node?: Maybe<PostWhereInput>;␊
      AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
      OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
      NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
    }␊
    ␊
    export interface PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      data: PostUpdateWithoutAuthorDataInput;␊
    }␊
    ␊
    export interface PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      update: PostUpdateWithoutAuthorDataInput;␊
      create: PostCreateWithoutAuthorInput;␊
    }␊
    ␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValues {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPreviousValuesPromise␊
      extends Promise<UserPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface User {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T = FragmentableArray<Post>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface UserNullablePromise␊
      extends Promise<User | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T = FragmentableArray<Post>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface PostEdge {␊
      node: Post;␊
      cursor: String;␊
    }␊
    ␊
    export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {␊
      node: <T = PostPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PostEdgeSubscription␊
      extends Promise<AsyncIterator<PostEdge>>,␊
        Fragmentable {␊
      node: <T = PostSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PostSubscriptionPayload {␊
      mutation: MutationType;␊
      node: Post;␊
      updatedFields: String[];␊
      previousValues: PostPreviousValues;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadPromise␊
      extends Promise<PostSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = PostPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = PostPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<PostSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = PostSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = PostPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface PostConnection {␊
      pageInfo: PageInfo;␊
      edges: PostEdge[];␊
    }␊
    ␊
    export interface PostConnectionPromise␊
      extends Promise<PostConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<PostEdge>>() => T;␊
      aggregate: <T = AggregatePostPromise>() => T;␊
    }␊
    ␊
    export interface PostConnectionSubscription␊
      extends Promise<AsyncIterator<PostConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregatePostSubscription>() => T;␊
    }␊
    ␊
    export interface Post {␊
      id: ID_Output;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPromise extends Promise<Post>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscription␊
      extends Promise<AsyncIterator<Post>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
      author: <T = UserSubscription>() => T;␊
    }␊
    ␊
    export interface PostNullablePromise␊
      extends Promise<Post | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PostPreviousValues {␊
      id: ID_Output;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPreviousValuesPromise␊
      extends Promise<PostPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
    }␊
    ␊
    export interface PostPreviousValuesSubscription␊
      extends Promise<AsyncIterator<PostPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface BatchPayload {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayloadPromise␊
      extends Promise<BatchPayload>,␊
        Fragmentable {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayload>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T = UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T = UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregatePost {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregatePostPromise␊
      extends Promise<AggregatePost>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregatePostSubscription␊
      extends Promise<AsyncIterator<AggregatePost>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayload {␊
      mutation: MutationType;␊
      node: User;␊
      updatedFields: String[];␊
      previousValues: UserPreviousValues;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadPromise␊
      extends Promise<UserSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = UserPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = UserPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface UserConnection {␊
      pageInfo: PageInfo;␊
      edges: UserEdge[];␊
    }␊
    ␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T = AggregateUserPromise>() => T;␊
    }␊
    ␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateUserSubscription>() => T;␊
    }␊
    ␊
    export type Long = string;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [␊
      {␊
        name: "Post",␊
        embedded: false␊
      },␊
      {␊
        name: "User",␊
        embedded: false␊
      }␊
    ];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const prisma: Prisma;␊
    `
