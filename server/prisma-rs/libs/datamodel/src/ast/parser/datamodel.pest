// ######################################
// Global (builtin) expressions
// ######################################

// Treat every whitespace the same
WHITESPACE = _{ SPACE_SEPARATOR | NEWLINE }
// Comment ignores everything until end of line.
// TODO: As soon as we include the comments in the AST, we need to move from silent (_) to atomic (@)
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

// ######################################
// Base building blocks
// ######################################
// TODO: Ask for proper format.
identifier = @{ ASCII_ALPHA ~ ( "_" | ASCII_ALPHANUMERIC)* } 

// Literals
numeric_literal = @{ ("-")? ~ ASCII_DIGIT+ ~("." ~ ASCII_DIGIT+)? }

// String, with support for escaped stuff and interpolations.
string_escaped_predefined = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" | "${" }
string_escape     = { "\\" ~ string_escaped_predefined }
// This is only used to escape the parser. The string above is still treated as atomic.
string_interpolate_escape = !{ ("${" ~ expression ~ "}") }
string_raw = { (!("\\" | "\"" | NEWLINE | "${") ~ (ANY))+ }
string_content = @{ (string_raw | string_escape | string_interpolate_escape)* }
string_literal = { "\"" ~ string_content ~ "\"" }

boolean_true  = { "true" }
boolean_false = { "false" }
boolean_literal =  @{ boolean_true | boolean_false }

constant_literal = @{ ASCII_ALPHA+ }

// ######################################
// Expression support
// ######################################

function = { identifier ~ "(" ~ (argument_value ~ ("," ~ argument_value)*)? ~ ")" }
array_expression = { "[" ~ expression ~ ( ", " ~ expression )* ~ "]" }
expression = { array_expression | function | numeric_literal | string_literal | boolean_literal | constant_literal }

// ######################################
// Arguments
// ######################################
argument_name = { (!":" ~ identifier)+ }
argument_value = { expression }
argument = { (argument_name ~ ":" ~ argument_value) }

// ######################################
// Directives
// ######################################
directive_arguments = { "(" ~ ((argument ~ ("," ~ argument)*)?) ~ ")" }
directive_single_argument = { "(" ~ argument_value ~ ")" }
// This is a poor-mans version of namespacing
directive_name = @{ (identifier ~ ".")? ~ identifier }
// A directive either has one unnamed argument or any number of named arguments or no argument.
directive = { directive_name ~ (directive_arguments | directive_single_argument ) ? }

// ######################################
// Field declarations
// ######################################
optional_type = { identifier ~ ("?") }
base_type = { identifier } // Called base type to not conflict with type rust keyword
list_type = { identifier ~ "[]" }

// Pest is greedy, order is very important here.
field_type = { list_type | optional_type | base_type }

// Field
default_value = { "=" ~ expression }
// TODO: We want to force a line break after a field declaration.
// For this, we have to rely on pests new '-' operator.
// Progress tracked here: https://github.com/pest-parser/pest/issues/271
field_declaration = { identifier ~ (":")? ~ field_type ~ default_value? ~ ( "@" ~ directive )* }

// ######################################
// Model declarations
// ######################################
model_declaration = { "model" ~ identifier ~ "{" ~ ( field_declaration | ( "@@" ~ directive )  )* ~ "}" }

// ######################################
// Enum declarations
// ######################################
enum_field_declaration = @{ ASCII_ALPHA_UPPER+ }
enum_declaration = { "enum" ~ identifier ~ "{" ~ (enum_field_declaration | ( "@@" ~ directive )  )* ~ "}" }

// ######################################
// Source block
// ######################################
source_key_value = { identifier ~ "=" ~ expression }
source_properties = { "properties" ~ "{" ~ source_key_value* ~ "}" }
// Only allows ONE properties block.
source_block = { "source" ~ identifier ~ "{" ~ source_key_value* ~ source_properties? ~ source_key_value* ~ "}" }

// ######################################
// Datamodel
// ######################################
datamodel = { SOI ~ (model_declaration | enum_declaration | source_block )* ~ EOI }

// ######################################
// String Interpolation
// Called seperatedly, but falls back 
// to expression.
// ######################################
// We can safely assume that our strings are stripped of their "s and 
// that strings do not contain new lines.

// Greedy match escaped interpolation or any char. Do not match interpolation.
string_any = @{ ANY }
string_escaped_interpolation = @{ "\\${" }
string_interpolated = { SOI ~ (
                            // This is basically everything except an expression, using the escape trick from above.
                            (!("${") ~ ( string_escaped_interpolation | string_any))+ | 
                            // This is an expression.
                            ("${" ~ expression ~ "}")
                        )* ~ EOI }