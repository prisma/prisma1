use crate::{
    data_resolvers::{DataResolver, SelectQuery, Sqlite},
    protobuf::prelude::*,
    PrismaResult,
};
use prisma_query::{
    ast::*,
    visitor::{self, *},
};

impl DataResolver for Sqlite {
    fn select_nodes(&self, query: SelectQuery) -> PrismaResult<(Vec<Node>, Vec<String>)> {
        let project = query.project.clone();
        let database_name = project.db_name();

        self.with_connection(database_name, |conn| {
            let selected_fields = query
                .model
                .fields()
                .find_many_from_scalar(&query.selected_fields);

            let field_names: Vec<String> = selected_fields
                .iter()
                .map(|f| f.db_name().to_string())
                .collect();

            // BASE QUERY
            let base_query = Select::from(query.model.table())
                .so_that(query.conditions)
                .offset(query.skip);

            // SELECT FIELDS
            let with_names = field_names
                .iter()
                .map(AsRef::as_ref)
                .fold(base_query, |ast, field| ast.column(field));

            // ORDER BY
            let ordered = query
                .ordering
                .into_iter()
                .fold(with_names, |ast, ordering| {
                    ordering
                        .into_iter()
                        .fold(ast, |ast, order_by| ast.order_by(order_by))
                });

            // LIMIT
            let query_ast = query
                .limit
                .into_iter()
                .fold(ordered, |ast, limit| ast.limit(limit));

            let (query_sql, params) = dbg!(visitor::Sqlite::build(query_ast));
            let mut stmt = conn.prepare(&query_sql)?;

            let nodes_iter = stmt.query_map(&params, |row| {
                let mut values = Vec::new();

                for (i, field) in selected_fields.iter().enumerate() {
                    let prisma_value = Some(Self::fetch_value(field.type_identifier, &row, i));
                    values.push(ValueContainer { prisma_value });
                }

                Node { values }
            })?;

            let mut nodes = Vec::new();
            for node in nodes_iter {
                nodes.push(node?);
            }

            Ok(dbg!((nodes, field_names)))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data_resolvers::{DataResolver, SelectQuery};
    use crate::models::prelude::*;
    use chrono::{DateTime, Utc};
    use serde_json::{self, json};
    use std::collections::BTreeSet;

    fn create_test_structure(sqlite: &Sqlite) -> PrismaResult<()> {
        sqlite
            .with_connection("graphcool", |conn| {
                conn.execute_batch(
                    "BEGIN;
                     DROP TABLE IF EXISTS graphcool.user;
                     CREATE TABLE graphcool.user(id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT, updated_at datetime(3));
                     INSERT INTO graphcool.user (name, updated_at) values ('Musti', 1549046025567);
                     INSERT INTO graphcool.user (name, updated_at) values ('Naukio', 1549046025567);
                     COMMIT;",
                )
                .unwrap();
                Ok(())
            })?;

        Ok(())
    }

    fn create_legacy_project() -> ProjectRef {
        let project_json = json!({
            "id": "graphcool",
            "functions": [],
            "schema": {
                "models": [
                    {
                        "name": "user",
                        "stableIdentifier": "user",
                        "isEmbedded": false,
                        "fields": [
                            {
                                "name": "id",
                                "typeIdentifier": "GraphQLID",
                                "isRequired": true,
                                "isList": false,
                                "isUnique": true,
                                "isHidden": false,
                                "isReadonly": true,
                                "isAutoGenerated": true
                            },
                            {
                                "name": "old_name",
                                "typeIdentifier": "String",
                                "isRequired": true,
                                "isList": false,
                                "isUnique": true,
                                "isHidden": false,
                                "isReadonly": false,
                                "isAutoGenerated": false,
                                "manifestation": {
                                    "dbName": "name"
                                }
                            },
                            {
                                "name": "updated_at",
                                "typeIdentifier": "DateTime",
                                "isRequired": false,
                                "isList": false,
                                "isUnique": false,
                                "isHidden": false,
                                "isReadonly": false,
                                "isAutoGenerated": false
                            }
                        ],
                    }
                ],
                "relations": [],
                "enums": [],
            }
        });

        let project_template: ProjectTemplate = serde_json::from_value(project_json).unwrap();
        project_template.into()
    }

    #[test]
    fn test_simple_select_by_where() {
        let sqlite = Sqlite::new(1, true).unwrap();
        create_test_structure(&sqlite).unwrap();

        let project = create_legacy_project();

        let model = project.schema().find_model("user").unwrap();
        let field = model.fields().find_from_scalar("name").unwrap();
        let find_by = PrismaValue::String(String::from("Musti"));

        let fields: BTreeSet<String> = model
            .fields()
            .scalar()
            .iter()
            .map(|f| f.db_name().to_string())
            .collect();

        let conditions = ConditionTree::single(field.model_column().equals(find_by));

        let query = SelectQuery {
            project: project,
            model: model,
            selected_fields: fields,
            conditions: conditions,
            ordering: None,
            skip: 0,
            limit: None,
        };

        let datetime: DateTime<Utc> = DateTime::from_utc(
            chrono::NaiveDateTime::from_timestamp(1549046025, 567000000),
            Utc,
        );

        let (nodes, fields) = sqlite.select_nodes(query).unwrap();

        assert_eq!(1, nodes.len());
        assert_eq!(
            vec![
                String::from("id"),
                String::from("name"),
                String::from("updated_at")
            ],
            fields
        );

        let result = &nodes[0];

        assert_eq!(3, result.len());
        assert_eq!(
            Some(&PrismaValue::GraphqlId(GraphqlId {
                id_value: Some(graphql_id::IdValue::Int(1))
            })),
            result.get(0)
        );
        assert_eq!(
            Some(&PrismaValue::String(String::from("Musti"))),
            result.get(1)
        );
        assert_eq!(
            Some(&PrismaValue::DateTime(datetime.to_rfc3339())),
            result.get(2)
        );
    }

    #[test]
    fn test_get_nodes_with_no_filters() {
        let sqlite = Sqlite::new(1, true).unwrap();
        create_test_structure(&sqlite).unwrap();

        let project = create_legacy_project();

        let model = project.schema().find_model("user").unwrap();

        let fields: BTreeSet<String> = model
            .fields()
            .scalar()
            .iter()
            .map(|f| f.db_name().to_string())
            .collect();

        let query = SelectQuery {
            project: project,
            model: model,
            selected_fields: fields,
            conditions: ConditionTree::NoCondition,
            ordering: None,
            skip: 0,
            limit: None,
        };

        let (nodes, fields) = sqlite.select_nodes(query).unwrap();

        assert_eq!(2, nodes.len());
        assert_eq!(3, fields.len());
    }
}
